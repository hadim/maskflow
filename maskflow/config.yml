# A name for the detector.
NAME: "Default"

# Name of the object classes.
# The element BACKGROUND is assumed to be of class ID 0.
# DO NOT PUT BACKGROUND object in CLASS_NAMES.
CLASS_NAMES: ["object"]

# Maximum number of ground truth instances in one image
MAX_GT_INSTANCES: 100

# Input image resizing
# Generally, use the "square" resizing mode for training and inferencing
# and it should work well in most cases. In this mode, images are scaled
# up such that the small side is = IMAGE_MIN_DIM, but ensuring that the
# scaling doesn't make the long side > IMAGE_MAX_DIM. Then the image is
# padded with zeros to make it a square so multiple images can be put
# in one batch.
# Available resizing modes:
# none:   No resizing or padding. Return the image unchanged.
# square: Resize and pad with zeros to get a square image
#         of size [max_dim, max_dim].
# pad64:  Pads width and height with zeros to make them multiples of 64.
#         If IMAGE_MIN_DIM or IMAGE_MIN_SCALE are not None, then it scales
#         up before padding. IMAGE_MAX_DIM is ignored in this mode.
#         The multiple of 64 is needed to ensure smooth scaling of feature
#         maps up and down the 6 levels of the FPN pyramid (2**6=64).
# crop:   Picks random crops from the image. First, scales the image based
#         on IMAGE_MIN_DIM and IMAGE_MIN_SCALE, then picks a random crop of
#         size IMAGE_MIN_DIM x IMAGE_MIN_DIM. Can be used in training only.
#         IMAGE_MAX_DIM is not used in this mode.
IMAGE_RESIZE_MODE: "square"
IMAGE_MIN_DIM: 800
IMAGE_MAX_DIM: 1024

# Minimum scaling ratio. Checked after MIN_IMAGE_DIM and can force further
# up scaling. For example, if set to 2 then images are scaled up to double
# the width and height, or more, even if MIN_IMAGE_DIM doesn't require it.
# Howver, in 'square' mode, it can be overruled by IMAGE_MAX_DIM.
IMAGE_MIN_SCALE: 1.0

# Image mean (RGB)
MEAN_PIXEL: [123.7, 116.8, 103.9]

# Subtract the mean and divide by the standard deviation
NORMALIZE_IMAGE: False

# The strides of each layer of the FPN Pyramid. These values
# are based on a Resnet101 backbone.
BACKBONE_STRIDES: [4, 8, 16, 32, 64]

# Length of square anchor side in pixels
RPN_ANCHOR_SCALES: [32, 64, 128, 256, 512]

# Ratios of anchors at each cell (width/height)
# A value of 1 represents a square anchor, and 0.5 is a wide anchor
RPN_ANCHOR_RATIOS: [0.5, 1, 2]

# Anchor stride
# If 1 then anchors are created for each cell in the backbone feature map.
# If 2, then anchors are created for every other cell, and so on.
RPN_ANCHOR_STRIDE: 1

# Use RPN ROIs or externally generated ROIs for training
# Keep this True for most situations. Set to False if you want to train
# the head branches on ROI generated by code rather than the ROIs from
# the RPN. For example, to debug the classifier head without having to
# train the RPN.
USE_RPN_ROIS: True

# Train or freeze batch normalization layers
#     None: Train BN layers. This is the normal mode
#     False: Freeze BN layers. Good when using a small batch size
#     True: (don't use). Set layer in training mode even when inferencing
TRAIN_BN: False  # Defaulting to False since batch size is often small

# Size of the top-down layers used to build the feature pyramid
TOP_DOWN_PYRAMID_SIZE: 256

# Backbone network architecture
# Supported values are: resnet50, resnet101.
BACKBONE: "resnet50"

# ROIs kept after non-maximum supression (training and inference)
POST_NMS_ROIS_TRAINING: 2000
POST_NMS_ROIS_INFERENCE: 1000

# Non-max suppression threshold to filter RPN proposals.
# You can increase this during training to generate more propsals.
RPN_NMS_THRESHOLD: 0.7

# Bounding box refinement standard deviation for RPN and final detections.
RPN_BBOX_STD_DEV: [0.1, 0.1, 0.2, 0.2]
BBOX_STD_DEV: [0.1, 0.1, 0.2, 0.2]